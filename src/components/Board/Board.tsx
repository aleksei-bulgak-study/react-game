import React, { ReactElement, useCallback, useEffect, useState } from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import EmptyBoard from './EmptyBoard';
import BoardElements from './BoardElements';
import { InferProps } from 'prop-types';

const ARROWS = {
    right: 39,
    down: 40,
    up: 38,
    left: 37,
};

interface Position {
    x: number;
    y: number;
}

interface CardElement {
    coordinates: Position;
    matrix: Position;
    position: number;
    value: number;
    delete: boolean;
    visited: boolean;
}

const sortCardsByYCoordinates = (cards: Array<CardElement>): Array<CardElement> => {
    return cards.sort((f, s) => {
        if (f.matrix.y < s.matrix.y) {
            return -1;
        }
        if (f.matrix.y > s.matrix.y) {
            return 1;
        }
        return 0;
    });
};

const shiftToLeft = (cards: Array<CardElement>): void => {
    for (let index = 0; index < cards.length; index++) {
        const left = cards[index];
        if (index === cards.length - 1) {
            if (!left.visited) left.matrix.y = index > 0 ? cards[index - 1].matrix.y + 1 : 0;
        } else {
            const right = cards[index + 1];
            if (left.visited) {
                right.matrix.y = left.matrix.y + 1;
            }
            if (left.value === right.value) {
                right.matrix.y = index;
                right.position = left.position;
                right.value += right.value;
                right.visited = true;
                left.delete = true;
            } else {
                left.matrix.y = index;
                right.matrix.y = index + 1;
            }
        }
        left.visited = true;
    }
};

const Board = ({
    className,
    size = 4,
    options = { elementsPerAction: 2, valuesAutoGenerated: [2, 4] },
    status,
    onStatusChange,
}: InferProps<typeof Board.propTypes>): ReactElement => {
    const positions = size * size;
    const [cards, setCards] = useState([] as Array<CardElement>);

    const addRandomValues = useCallback(() => {
        const newCards = [...cards];
        for (let index = 0; index < options.elementsPerAction; index++) {
            let emptyPositions = Array(positions)
                .fill(0)
                .map((_, index) => index);
            newCards.forEach((card) => (emptyPositions = emptyPositions.filter((pos) => card.position !== pos)));

            if (emptyPositions.length === 0) {
                onStatusChange({ ...status, failed: true });
                return;
            }

            const position = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
            const value = options.valuesAutoGenerated[Math.floor(Math.random() * options.valuesAutoGenerated.length)];
            const newCard = {
                position,
                coordinates: {
                    y: (Math.floor(position % size) * 100) / size,
                    x: (Math.floor(position / size) * 100) / size,
                },
                matrix: {
                    y: Math.floor(position % size),
                    x: Math.floor(position / size),
                },
                value,
                uuid: Math.random() * position,
                delete: false,
                visited: false,
            };
            newCards.push(newCard);
        }
        setCards(newCards);
    }, [cards, options, positions, size, status, onStatusChange]);

    const testLeft = useCallback(() => {
        const rows: CardElement[][] = [];
        cards.forEach((card) => {
            if (!rows[card.matrix.x]) {
                rows[card.matrix.x] = [];
            }
            rows[card.matrix.x].push({ ...card });
        });
        const sorted = rows.map(sortCardsByYCoordinates);
        sorted.forEach(shiftToLeft);
        setCards(
            sorted
                .flat()
                .filter((card) => !card.delete)
                .map((card) => {
                    card.visited = false;
                    card.coordinates.x = (card.matrix.x * 100) / size;
                    card.coordinates.y = (card.matrix.y * 100) / size;
                    return card;
                }),
        );
    }, [cards, size]);

    const keyHandler = useCallback(
        (e: UIEvent) => {
            if (e.which === ARROWS.down) {
            } else if (e.which === ARROWS.left) {
                testLeft();
            } else if (e.which === ARROWS.right) {
            } else if (e.which === ARROWS.up) {
            } else {
                return;
            }
            // addRandomValues();
        },
        [addRandomValues, testLeft],
    );

    useEffect(() => {
        addRandomValues();
    }, []);

    useEffect(() => {
        window.addEventListener('keydown', keyHandler);

        return () => {
            window.removeEventListener('keydown', keyHandler);
        };
    }, [cards, keyHandler]);

    return (
        <div className={`board ${className}`}>
            <div className="board__map">
                <EmptyBoard size={size} />
                <BoardElements cards={cards} />
            </div>
        </div>
    );
};

Board.propTypes = {
    className: PropTypes.string.isRequired,
    size: PropTypes.number,
    options: PropTypes.shape({
        elementsPerAction: PropTypes.number.isRequired,
        valuesAutoGenerated: PropTypes.arrayOf(PropTypes.number).isRequired,
    }),
};

export default styled(Board)`
    display: flex;
    align-items: center;
    justify-content: center;

    & > .board__map {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;

        width: clamp(500px, 50%, 1024px);
        height: clamp(500px, 50%, 1024px);

        background-color: ${(props) => props.theme.board.background};
        border-radius: 10px;
        position: relative;

        & .card {
            flex-basis: calc(100% / ${(props) => props.size} - 1rem);
            margin: 0.5rem;
            display: inline-block;
        }

        & > .board__panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;

            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        & > .real-panel {
            display: block;

            & > .card {
                width: calc(100% / ${(props) => props.size} - 1rem);
                height: calc(100% / ${(props) => props.size} - 1rem);
                margin: 0.5rem;
                display: inline-block;
                position: absolute;
            }
        }
    }
`;
