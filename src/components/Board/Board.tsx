import React, { ReactElement, useCallback, useEffect, useState } from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import EmptyBoard from './EmptyBoard';
import BoardElements from './BoardElements';
import { InferProps } from 'prop-types';
import { CardElement } from 'card';
import {
    convertToMatrix,
    convertToYMatrix,
    shiftToLeft,
    shiftToRight,
    shiftToTop,
    shiftToDown,
    sortCardsByPosition,
} from '../../utils/matrix';

const ARROWS = {
    right: 39,
    down: 40,
    up: 38,
    left: 37,
};

const Board = ({
    className,
    size = 4,
    options = { elementsPerAction: 2, valuesAutoGenerated: [2, 4] },
    status,
    onStatusChange,
}: InferProps<typeof Board.propTypes>): ReactElement => {
    const positions = size * size;
    const [cards, setCards] = useState([] as Array<CardElement>);

    const addRandomValues = useCallback(() => {
        const newCards = [...cards];
        for (let index = 0; index < options.elementsPerAction; index++) {
            let emptyPositions = Array(positions)
                .fill(0)
                .map((_, index) => index);
            newCards.forEach((card) => (emptyPositions = emptyPositions.filter((pos) => card.position !== pos)));

            if (emptyPositions.length === 0) {
                onStatusChange({ ...status, failed: true });
                return;
            }

            const position = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
            const value = options.valuesAutoGenerated[Math.floor(Math.random() * options.valuesAutoGenerated.length)];
            const newCard = {
                position,
                coordinates: {
                    y: (Math.floor(position % size) * 100) / size,
                    x: (Math.floor(position / size) * 100) / size,
                },
                matrix: {
                    y: Math.floor(position % size),
                    x: Math.floor(position / size),
                },
                value,
                uuid: Math.random(),
                delete: false,
                visited: false,
            };
            newCards.push(newCard);
        }
        setCards(sortCardsByPosition(newCards));
    }, [cards, options, positions, size, status, onStatusChange]);

    const performShift = useCallback(
        (directionFunction, convertToMatrix): void => {
            const sorted: CardElement[][] = convertToMatrix(cards);
            sorted.forEach((row) => directionFunction(row, size));
            setCards(
                sortCardsByPosition(
                    sorted
                        .flat()
                        .filter((card) => !card.delete)
                        .map((card) => {
                            card.visited = false;
                            card.coordinates.x = (card.matrix.x * 100) / size;
                            card.coordinates.y = (card.matrix.y * 100) / size;
                            card.position = card.matrix.y + card.matrix.x * size;
                            return card;
                        }),
                ),
            );
        },
        [cards, size],
    );

    const keyHandler = useCallback(
        (e: UIEvent) => {
            if (e.which === ARROWS.down) {
                performShift(shiftToDown, convertToYMatrix);
            } else if (e.which === ARROWS.left) {
                performShift(shiftToLeft, convertToMatrix);
            } else if (e.which === ARROWS.right) {
                performShift(shiftToRight, convertToMatrix);
            } else if (e.which === ARROWS.up) {
                performShift(shiftToTop, convertToYMatrix);
            } else {
                return;
            }
            // addRandomValues();
        },
        [addRandomValues, performShift],
    );

    useEffect(() => {
        addRandomValues();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    useEffect(() => {
        window.addEventListener('keydown', keyHandler);

        return () => {
            window.removeEventListener('keydown', keyHandler);
        };
    }, [cards, keyHandler]);

    return (
        <div className={`board ${className}`}>
            <div className="board__map">
                <EmptyBoard size={size} />
                <BoardElements cards={cards} />
            </div>
        </div>
    );
};

Board.propTypes = {
    className: PropTypes.string.isRequired,
    size: PropTypes.number,
    options: PropTypes.shape({
        elementsPerAction: PropTypes.number.isRequired,
        valuesAutoGenerated: PropTypes.arrayOf(PropTypes.number).isRequired,
    }),
};

export default styled(Board)`
    display: flex;
    align-items: center;
    justify-content: center;

    & > .board__map {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;

        width: clamp(500px, 50%, 1024px);
        height: clamp(500px, 50%, 1024px);

        background-color: ${(props) => props.theme.board.background};
        border-radius: 10px;
        position: relative;

        & .card {
            flex-basis: calc(100% / ${(props) => props.size} - 1rem);
            margin: 0.5rem;
            display: inline-block;
        }

        & > .board__panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;

            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        & > .real-panel {
            display: block;

            & > .card {
                width: calc(100% / ${(props) => props.size} - 1rem);
                height: calc(100% / ${(props) => props.size} - 1rem);
                margin: 0.5rem;
                display: inline-block;
                position: absolute;
            }
        }
    }
`;
