import React, { Dispatch, FC, SetStateAction, useCallback, useEffect, useState } from 'react';
import styled from 'styled-components';
import EmptyBoard from './EmptyBoard';
import BoardElements from './BoardElements';
import { CardElement } from 'card';
import {
    convertToMatrix,
    convertToYMatrix,
    shiftToLeft,
    shiftToRight,
    shiftToTop,
    shiftToDown,
    sortCardsByPosition,
} from '../../utils/matrix';
import { Status } from 'status';
import { Settings } from 'settings';

type BoardProps = {
    className?: string;
    status: Status;
    onStatusChange: Dispatch<SetStateAction<Status>>;
    onScoreChange: Dispatch<SetStateAction<number>>;
    options: Settings;
};

const ARROWS = {
    right: 39,
    down: 40,
    up: 38,
    left: 37,
};

const Board: FC<BoardProps> = ({ className, options, status, onStatusChange, onScoreChange }) => {
    const positions = options.boardSize * options.boardSize;
    const [cards, setCards] = useState([] as Array<CardElement>);

    const addRandomValues = useCallback(
        (cards: CardElement[]) => {
            const newCards = [...cards];
            for (let index = 0; index < options.elementsPerAction; index++) {
                let emptyPositions = Array(positions)
                    .fill(0)
                    .map((_, index) => index);
                newCards.forEach((card) => (emptyPositions = emptyPositions.filter((pos) => card.position !== pos)));

                if (emptyPositions.length === 0) {
                    onStatusChange({ ...status, failed: true, inProgress: false });
                    return;
                }

                const position = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
                const value =
                    options.valuesAutoGenerated[Math.floor(Math.random() * options.valuesAutoGenerated.length)];
                const newCard = {
                    position,
                    coordinates: {
                        y: (Math.floor(position % options.boardSize) * 100) / options.boardSize,
                        x: (Math.floor(position / options.boardSize) * 100) / options.boardSize,
                    },
                    matrix: {
                        y: Math.floor(position % options.boardSize),
                        x: Math.floor(position / options.boardSize),
                    },
                    value,
                    uuid: Math.random(),
                    delete: false,
                    visited: false,
                };
                newCards.push(newCard);
            }
            setCards(sortCardsByPosition(newCards));
        },
        [options, positions, status, onStatusChange],
    );

    const performShift = useCallback(
        (directionFunction, convertToMatrix): CardElement[] => {
            const sorted: CardElement[][] = convertToMatrix(cards);
            let scored = 0;
            sorted.forEach((row) => (scored += directionFunction(row, options.boardSize)));

            const updatedCards = sortCardsByPosition(
                sorted
                    .flat()
                    .filter((card) => !card.delete)
                    .map((card) => {
                        card.visited = false;
                        card.coordinates.x = (card.matrix.x * 100) / options.boardSize;
                        card.coordinates.y = (card.matrix.y * 100) / options.boardSize;
                        card.position = card.matrix.y + card.matrix.x * options.boardSize;
                        return card;
                    }),
            );
            setCards(updatedCards);
            onScoreChange(previousScore => previousScore + scored);
            return updatedCards;
        },
        [cards, options, onScoreChange],
    );

    const checkMaxValue = useCallback(
        (cards: CardElement[]) => {
            const maxValue = Math.max(...cards.map((card) => card.value));
            if (maxValue === options.maxValue) {
                onStatusChange((prevStatus) => ({ ...prevStatus, success: true, inProgress: false }) as Status);
            }
        },
        [onStatusChange, options],
    );

    const keyHandler = useCallback(
        (e: UIEvent) => {
            let updatedCards: CardElement[] = [];
            if (e.which === ARROWS.down) {
                updatedCards = performShift(shiftToDown, convertToYMatrix);
            } else if (e.which === ARROWS.left) {
                updatedCards = performShift(shiftToLeft, convertToMatrix);
            } else if (e.which === ARROWS.right) {
                updatedCards = performShift(shiftToRight, convertToMatrix);
            } else if (e.which === ARROWS.up) {
                updatedCards = performShift(shiftToTop, convertToYMatrix);
            } else {
                return;
            }
            checkMaxValue(updatedCards);
            addRandomValues(updatedCards);
        },
        [addRandomValues, performShift, checkMaxValue],
    );

    useEffect(() => {
        addRandomValues([]);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    useEffect(() => {
        window.addEventListener('keydown', keyHandler);

        return () => {
            window.removeEventListener('keydown', keyHandler);
        };
    }, [cards, keyHandler]);

    return (
        <div className={`board ${className}`}>
            <div className="board__map">
                <EmptyBoard size={options.boardSize} />
                <BoardElements cards={cards} />
            </div>
        </div>
    );
};

export default styled(Board)`
    display: flex;
    align-items: center;
    justify-content: center;

    & > .board__map {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;

        width: clamp(500px, 50%, 1024px);
        height: clamp(500px, 50%, 1024px);

        background-color: ${(props) => props.theme.board.background};
        border-radius: 10px;
        position: relative;

        & .card {
            flex-basis: calc(100% / ${(props) => props.options.boardSize} - 1rem);
            margin: 0.5rem;
            display: inline-block;
        }

        & > .board__panel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;

            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        & > .real-panel {
            display: block;

            & > .card {
                width: calc(100% / ${(props) => props.options.boardSize} - 1rem);
                height: calc(100% / ${(props) => props.options.boardSize} - 1rem);
                margin: 0.5rem;
                display: inline-block;
                position: absolute;
            }
        }
    }
`;
